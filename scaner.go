package main

import (
	"bufio"
	"io"
	"log"
	"log/syslog"
	"math/rand"
	"net"
	"net/http"
	"strings"
	"time"
)

// ScanReport the main structs for further CVE/CWE/CPE analysis
type ScanReport struct {
	IP   string `json:"targetIP"`
	Vuln []Vulns
}
type Port struct {
	Number  string `json:"portNumber"`
	Service string `json:"nmapService"`
	Banner  string `json:"nullBanner"`
}

type Firmware struct {
	Device   string
	Firmware string
}

type Vulns struct {
	VPort Port
	VFirm Firmware
	CVEID string   `json:"cveID"`
	Link  []string `json:"sourceLink"`
}

func printChannelData(ch chan LogMessage) {
	// Logging is for test purposes only. Will be tested "in the field".
	// After "field" tests will pack it to a 'map[string][]string' and will return for
	// the CVEs/CPEs/CWEs processor for an analysis.
	var m LogMessage
	m = <-ch
	m.getLogger()
}

func (scan *ScanReport) logScanned(output bool) {
	logSpace := "\t"
	if output {
		f, err := syslog.New(syslog.LOG_SYSLOG, "goscanneroutput")
		if err != nil {
			log.Fatalf("error opening file: %v", err)
		}
		defer f.Close()
		logSpace = " "
		log.SetOutput(f)
	}
	for _, vuln := range scan.Vuln {
		for _, link := range vuln.Link {
			log.Println("IP=" + scan.IP + logSpace + "Port=" + vuln.VPort.Number + logSpace +
				"DeviceSoft=" + vuln.VFirm.Device + logSpace + "Version=" + vuln.VFirm.Firmware +
				logSpace + "CVE=" + vuln.CVEID + logSpace + "URL=" + link)
		}
	}

}

func makeRandID(len int) string {
	rand.Seed(time.Now().UnixNano())
	baseRunes := []rune("0123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789")
	res := make([]rune, len)
	for i := 0; i < len; i++ {
		res[i] = baseRunes[rand.Intn(len)]
	}
	return string(res)
}

func getSIPPayload(target string) []byte {
	var sipPayload []byte
	// Making branch
	randBranch := makeRandID(8)
	// Making tag
	randTag := makeRandID(46)
	// Making call id

	fromAddr := "127.0.0.1"
	randCallId := makeRandID(24)
	baseText := "OPTIONS sip:100@" + target +
		" SIP/2.0\r\nVia: SIP/2.0/UDP " +
		fromAddr + ":5060;branch=z9hG4bK-" + randBranch +
		";rport\r\nMax-Forwards: 70\r\nTo: \"sipvicious\"<sip:100@1.1.1.1>\r\nFrom: \"sipvicious\"<sip:100@1.1.1.1>;tag=" +
		randTag + "\r\nUser-Agent: friendly-scanner\r\nCall-ID: " +
		randCallId + "\r\nContact: sip:100@" +
		fromAddr + ":5060\r\nCSeq: 1 OPTIONS\r\nAccept: application/sdp\r\nContent-Length: 0\n\n"
	sipPayload = []byte(baseText)
	return sipPayload
}

func (scan *ScanReport) doNVDDial(target string, verbose bool, ch chan LogMessage) {
	// Defining basic vars for clearance and making code more readable
	var m LogMessage
	protocol := "tcp"
	tcpDialTimeout := 500 * time.Millisecond
	service := "ssh"
	logSpace := "\t"
	banner := make([]byte, 4096)

	if verbose {
		log.Println("Starting scan of the target " + target)
	}
	parsedTarget := strings.Split(target, ":")
	// Defining services from the ./assets/nmap-services.txt
	service = readServices(parsedTarget[1], protocol)

	// HTTP Request check as it's a default mode
	if parsedTarget[1] == "80" || parsedTarget[1] == "443" ||
		parsedTarget[1] == "8080" || parsedTarget[1] == "8443" {
		protocol = "http://"
		tr := &http.Transport{
			MaxIdleConns:       10,
			IdleConnTimeout:    15 * time.Second,
			DisableCompression: true,
		}
		client := &http.Client{
			Transport: tr,
			Timeout:   15 * time.Second,
		}
		hconn, err := client.Get(protocol + parsedTarget[0])
		if err != nil {
			m.MessageType = "error"
			m.IP = parsedTarget[0]
			m.PORT = parsedTarget[1]
			m.Message = parsedTarget[0] + logSpace + parsedTarget[1] + logSpace + "filtered/closed" +
				logSpace + "No Service" + logSpace + "No Banner"
			if verbose {
				m.Environment = "debugging"
			}
			ch <- m
			return
		}
		defer hconn.Body.Close()

		body, err := io.ReadAll(hconn.Body)
		if err != nil {
			banner = []byte("No banner")
		} else {
			banner = body[:]
		}
	} else {
		protocol = "tcp"
		// Changing default params for SIP devices
		if parsedTarget[1] == "5060" ||
			parsedTarget[1] == "5061" {
			tcpDialTimeout = 2000 * time.Millisecond
			protocol = "udp"
		}
		// Making main Socket connection as we'll proceed with it further
		conn, err := net.DialTimeout(protocol, target, tcpDialTimeout)
		if err != nil {
			m.MessageType = "error"
			m.IP = parsedTarget[0]
			m.PORT = parsedTarget[1]
			m.Message = parsedTarget[0] + logSpace + parsedTarget[1] + logSpace + "filtered/closed" +
				logSpace + "No Service" + logSpace + "No Banner"
			if verbose {
				m.Environment = "debugging"
			}
			ch <- m
			return
		}
		defer conn.Close()
		// Forming and sanding payload for the SIP-device
		if parsedTarget[1] == "5060" ||
			parsedTarget[1] == "5061" {
			// !NOTE: NEVER, like seriously... NEVER delete 'sipPayload' variable.
			// Write() works with uint32, and you need uint8 for SIP-device.
			sipPayload := getSIPPayload(parsedTarget[0])
			_, err = conn.Write(sipPayload)
			if err != nil {
				m.MessageType = "error"
				m.IP = parsedTarget[0]
				m.PORT = parsedTarget[1]
				m.Message = "Was not able to SEND the SIP OPTIONS payload to the PORT 5060"
				if verbose {
					m.Environment = "debugging"
				}
				ch <- m
				return
			}
		}
		// Setting up a buffer to read a banner
		br := bufio.NewReader(conn)
		conn.SetReadDeadline(time.Now().Add(tcpDialTimeout))
		n, err := io.ReadFull(br, banner)
		// Processing filtered/closed ports via 5060
		if err != nil && n == 0 {
			m.MessageType = "error"
			m.IP = parsedTarget[0]
			m.PORT = parsedTarget[1]
			m.Message = parsedTarget[0] + logSpace + parsedTarget[1] + logSpace + "filtered/closed" +
				logSpace + "No Service" + logSpace + "No Banner"
			if verbose {
				m.Environment = "debugging"
			}
			ch <- m
			return
		} else {
			banner = banner[:n]
		}
	}
	// Logging is for test purposes only. Will be tested "in the field".
	// After "field" tests will pack it to a 'map[string][]string' and will return for
	// the CVEs/CPEs/CWEs processor for an analysis.
	m.MessageType = "regular"
	m.IP = parsedTarget[0]
	m.PORT = parsedTarget[1]
	if verbose {
		m.Message = parsedTarget[0] + logSpace + parsedTarget[1] + logSpace + "opened" +
			logSpace + service + logSpace + string(banner[:])
	} else {
		m.Message = parsedTarget[0] + logSpace + parsedTarget[1] + logSpace + "opened" +
			logSpace + service + logSpace + string(banner[:9])
	}
	// Saving to process it for the future
	vuln := Vulns{VPort: Port{parsedTarget[1], service, string(banner)}}
	scan.IP = m.IP
	scan.Vuln = append(scan.Vuln, vuln)
	ch <- m
}

func defineTargetQueue(urls, ports []string) []string {
	var targets []string
	for _, url := range urls {
		for _, port := range ports {
			targets = append(targets, url+":"+port)
		}
	}
	return targets
}

func defineThreads(threads, queuelength int) int {
	// Auto threads count definition for async/sync propper work
	if d := threads * 2; d > queuelength {
		threads /= 4
		if threads == 0 {
			threads = 1
		}
	}
	return threads
}

func scanDeviceTarget(threads int, verbose bool, input ...[]string) ([]ScanReport, error) {
	// Defining basic vars for clearance and making code more readable
	urls := input[0]
	ports := input[1]
	var ch chan LogMessage
	var scannerResult ScanReport
	var res []ScanReport
	// Defining thread working variables to slice our port array properly
	sliceStart := 0
	increment := 0
	targets := defineTargetQueue(urls, ports)
	threads = defineThreads(threads, len(targets))
	divisionLeft := len(targets) % threads
	// Check if ports count is less than threads
	if len(targets) < threads {
		threads = len(targets)
	}
	// Wrapper loop to range through the correct incremented slice values
	for {
		ch = make(chan LogMessage)
		// Passing through target PORTs in threaded slice
		for _, target := range targets[sliceStart : sliceStart+threads] {
			// Increment and checking if we need to update slice start:end values
			increment++
			if increment == (sliceStart + threads) {
				sliceStart = increment
			}
			// Asynchronous call for the Dial function into channels.
			// Temporarily its string for logging purposes.
			// Will be map[string][]string.
			go scannerResult.doNVDDial(target, verbose, ch)
		}

		// Awaiting promised requests and logging all our channels
		for i := 0; i < threads; i++ {
			printChannelData(ch)
		}
		close(ch)
		if scannerResult.IP != "" {
			res = append(res, scannerResult)
			scannerResult = ScanReport{}
		}
		if (increment + threads) > len(targets) {
			if (increment+divisionLeft) > len(targets) || divisionLeft == 0 {
				break
			}
			threads = divisionLeft
		}
	}
	// 'return nil' here is for test purposes only. Will be tested "in the field".
	// After "field" tests will pack it to a 'map[string][]string' and will return for
	// the CVEs/CPEs/CWEs processor for an analysis.
	return res, nil
}
