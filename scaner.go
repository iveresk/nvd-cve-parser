package main

import (
	"bufio"
	"io"
	"net"
	"os"
	"strings"
	"time"
)

func printChannelData(ch chan LogMessage) {
	// Logging is for test purposes only. Will be tested "in the field".
	// After "field" tests will pack it to a 'map[string][]string' and will return for
	// the CVEs/CPEs/CWEs processor for an analysis.
	var m LogMessage
	m = <-ch
	m.getLogger()
}

func doNVDDial(target string, verbose bool, ch chan LogMessage) {
	// Defining basic vars for clearance and making code more readable
	protocol := "tcp"
	dialtimeout := 350 * time.Millisecond
	service := "ssh"
	logspace := "\t"
	var m LogMessage
	parsedtarget := strings.Split(target, ":")
	conn, err := net.DialTimeout(protocol, target, dialtimeout)
	if err != nil {
		m.MessageType = "error"
		m.IP = parsedtarget[0]
		m.PORT = parsedtarget[1]
		m.Message = parsedtarget[0] + logspace + parsedtarget[1] + logspace + "filtered/closed" +
			logspace + "No Service" + logspace + "No Banner"
		if verbose {
			m.Environment = "debugging"
		}
		ch <- m
		return
	}
	defer conn.Close()
	service = readServices(parsedtarget[1], protocol)
	br := bufio.NewReader(conn)
	banner := make([]byte, 256)
	n, berr := io.ReadFull(br, banner)
	if berr != nil {
		banner = []byte("No banner")
	} else {
		banner = banner[:n]
	}
	// Logging is for test purposes only. Will be tested "in the field".
	// After "field" tests will pack it to a 'map[string][]string' and will return for
	// the CVEs/CPEs/CWEs processor for an analysis.
	m.MessageType = "regular"
	m.IP = parsedtarget[0]
	m.PORT = parsedtarget[1]
	m.Message = parsedtarget[0] + logspace + parsedtarget[1] + logspace + "opened" +
		logspace + service + logspace + string(banner)
	ch <- m
}

func readServices(port, protocol string) string {
	var m LogMessage
	service := "No Service"
	expression := "([a-z|-]){1,32}[\\t|.]" + port + "/" + protocol
	readfile, err := os.ReadFile("./assets/nmap-services.txt")
	if err != nil {
		m.MessageType = "regular"
		m.Message = "There is no file ./assets/nmap-services.txt"
		m.getLogger()
	}
	services := string(readfile)
	for _, regex := range checkRegexp(expression, services) {
		service = strings.Split(string(regex), "\t")[0]
	}
	return service
}

func defineTargetQueue(urls, ports []string) []string {
	var targets []string
	for _, url := range urls {
		for _, port := range ports {
			targets = append(targets, url+":"+port)
		}
	}
	return targets
}

func scanDeviceTarget(threads int, verbose bool, input ...[]string) error {
	// TODO refactor it for the map[string][]string, error
	// Defining basic vars for clearance and making code more readable
	urls := input[0]
	ports := input[1]
	var ch chan LogMessage
	// Defining thread working variables to slice our port array properly
	slicestart := 0
	increment := 0
	targets := defineTargetQueue(urls, ports)
	// Check if ports count is less than threads
	if len(targets) < threads {
		threads = len(targets)
	}
	// TODO channel logic optimisation
	// Wrapper loop to range through the correct incremented slice values
	for {
		ch = make(chan LogMessage)
		// Passing through target PORTs in threaded slice
		for _, target := range targets[slicestart : slicestart+threads] {
			// Increment and checking if we need to update slice start:end values
			increment++
			if increment == (slicestart + threads) {
				slicestart = increment
			}
			// Asynchronous call for the Dial function into channels.
			// Temporarily its string for logging purposes.
			// Will be map[string][]string.
			go doNVDDial(target, verbose, ch)
		}
		// Awaiting promised requests and logging all our channels
		for i := 0; i < threads; i++ {
			printChannelData(ch)
		}
		close(ch)
		if (increment + threads) > len(ports) {
			break
		}
	}
	// 'return nil' here is for test purposes only. Will be tested "in the field".
	// After "field" tests will pack it to a 'map[string][]string' and will return for
	// the CVEs/CPEs/CWEs processor for an analysis.
	return nil
}
