package main

import (
	"bufio"
	"io"
	"log"
	"math/rand"
	"net"
	"net/http"
	"strings"
	"time"
)

// ScanReport the main structs for further CVE/CWE/CPE analysis
type ScanReport struct {
	IP   string `json:"target_ip"`
	Vuln []Vulns
}
type Port struct {
	Number  string `json:"port_number"`
	Service string `json:"nmap_service"`
	Banner  string `json:"null_banner"`
}

type Firmware struct {
	Device   string
	Firmware string
}

type Vulns struct {
	VPort Port
	VFirm Firmware
	CVEID string   `json:"cve_id"`
	Link  []string `json:"source_link"`
}

func printChannelData(ch chan LogMessage) {
	// Logging is for test purposes only. Will be tested "in the field".
	// After "field" tests will pack it to a 'map[string][]string' and will return for
	// the CVEs/CPEs/CWEs processor for an analysis.
	var m LogMessage
	m = <-ch
	m.getLogger()
}

func (scan *ScanReport) logScanned() {
	logspace := "\t"
	for _, vuln := range scan.Vuln {
		for _, link := range vuln.Link {
			log.Println(scan.IP + logspace + vuln.VPort.Number + logspace +
				vuln.VFirm.Device + logspace + vuln.VFirm.Firmware +
				logspace + vuln.CVEID + logspace + link)
		}
	}

}

func makeRandID(len int) string {
	rand.Seed(time.Now().UnixNano())
	baserunes := []rune("0123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789")
	res := make([]rune, len)
	for i := 0; i < len; i++ {
		res[i] = baserunes[rand.Intn(len)]
	}
	return string(res)
}

func getSIPPayload(target string) []byte {
	var sippayload []byte
	// Making branch
	randbranch := makeRandID(8)
	// Making tag
	randtag := makeRandID(46)
	// Making call id

	fromaddr := "127.0.0.1"
	randcallid := makeRandID(24)
	basetext := "OPTIONS sip:100@" + target + " SIP/2.0\r\nVia: SIP/2.0/UDP " + fromaddr + ":5060;branch=z9hG4bK-" + randbranch + ";rport\r\nMax-Forwards: 70\r\nTo: \"sipvicious\"<sip:100@1.1.1.1>\r\nFrom: \"sipvicious\"<sip:100@1.1.1.1>;tag=" + randtag + "\r\nUser-Agent: friendly-scanner\r\nCall-ID: " + randcallid + "\r\nContact: sip:100@" + fromaddr + ":5060\r\nCSeq: 1 OPTIONS\r\nAccept: application/sdp\r\nContent-Length: 0\n\n"
	sippayload = []byte(basetext)
	return sippayload
}

func (scan *ScanReport) doNVDDial(target string, verbose bool, ch chan LogMessage) {
	// Defining basic vars for clearance and making code more readable
	var m LogMessage
	protocol := "tcp"
	dialtimeout := 500 * time.Millisecond
	service := "ssh"
	logspace := "\t"
	banner := make([]byte, 4096)

	if verbose {
		log.Println("Starting scan of the target " + target)
	}
	parsedtarget := strings.Split(target, ":")
	// Defining services from the ./assets/nmap-services.txt
	service = readServices(parsedtarget[1], protocol)

	// HTTP Request check as it's a default mode
	if parsedtarget[1] == "80" || parsedtarget[1] == "443" ||
		parsedtarget[1] == "8080" || parsedtarget[1] == "8443" {
		protocol = "http://"
		if parsedtarget[1] == "443" || parsedtarget[1] == "8443" {
			protocol = "https://"
		}
		hconn, err := http.Get(protocol + parsedtarget[0])
		if err != nil {
			if verbose {
				log.Println("No http connection for the " + parsedtarget[0])
			}
		}
		defer hconn.Body.Close()
		body, err := io.ReadAll(hconn.Body)
		if err != nil {
			banner = []byte("No banner")
		} else {
			banner = body[:]
		}
	} else {
		// Changing default params for SIP devices
		if parsedtarget[1] == "5060" {
			dialtimeout = 3000 * time.Millisecond
			protocol = "udp"
		}
		// Making main Socket connection as we'll proceed with it further
		conn, err := net.DialTimeout(protocol, target, dialtimeout)
		if err != nil {
			m.MessageType = "error"
			m.IP = parsedtarget[0]
			m.PORT = parsedtarget[1]
			m.Message = parsedtarget[0] + logspace + parsedtarget[1] + logspace + "filtered/closed" +
				logspace + "No Service" + logspace + "No Banner"
			if verbose {
				m.Environment = "debugging"
			}
			ch <- m
			return
		}
		defer conn.Close()
		// Forming and sanding payload for the SIP-device
		if parsedtarget[1] == "5060" {
			// !NOTE: NEVER, like seriously... NEVER delete 'sippayload' variable.
			// Write() works with uint32, and you need uint8 for SIP-device.
			sippayload := getSIPPayload(parsedtarget[0])
			_, err = conn.Write(sippayload)
			if verbose && err != nil {
				m.MessageType = "error"
				m.IP = parsedtarget[0]
				m.PORT = parsedtarget[1]
				m.Message = "Was not able to SEND the SIP OPTIONS payload to the PORT 5060"
				m.Environment = "debugging"
				ch <- m
				return
			}
		}
		// Setting up a buffer to read a banner
		br := bufio.NewReader(conn)
		conn.SetReadDeadline(time.Now().Add(dialtimeout))
		n, err := io.ReadFull(br, banner)
		if err != nil && n == 0 {
			banner = []byte("No banner")
		} else {
			banner = banner[:n]
		}
	}
	// Logging is for test purposes only. Will be tested "in the field".
	// After "field" tests will pack it to a 'map[string][]string' and will return for
	// the CVEs/CPEs/CWEs processor for an analysis.
	m.MessageType = "regular"
	m.IP = parsedtarget[0]
	m.PORT = parsedtarget[1]
	m.Message = parsedtarget[0] + logspace + parsedtarget[1] + logspace + "opened" +
		logspace + service + logspace + string(banner[:9])
	// Saving to process it for the future
	vuln := Vulns{VPort: Port{parsedtarget[1], service, string(banner)}}
	scan.IP = m.IP
	scan.Vuln = append(scan.Vuln, vuln)
	ch <- m
}

func defineTargetQueue(urls, ports []string) []string {
	var targets []string
	for _, url := range urls {
		for _, port := range ports {
			targets = append(targets, url+":"+port)
		}
	}
	return targets
}

func defineThreads(threads, queuelength int) int {
	// Auto threads count definition for async/sync propper work
	if d := threads * 2; d > queuelength {
		threads /= 4
		if threads == 0 {
			threads = 1
		}
	}
	return threads
}

func scanDeviceTarget(threads int, verbose bool, input ...[]string) ([]ScanReport, error) {
	// Defining basic vars for clearance and making code more readable
	urls := input[0]
	ports := input[1]
	var ch chan LogMessage
	var scannerResult ScanReport
	var res []ScanReport
	// Defining thread working variables to slice our port array properly
	slicestart := 0
	increment := 0
	targets := defineTargetQueue(urls, ports)
	threads = defineThreads(threads, len(targets))
	divisionleft := len(targets) % threads
	// Check if ports count is less than threads
	if len(targets) < threads {
		threads = len(targets)
	}
	// Wrapper loop to range through the correct incremented slice values
	for {
		ch = make(chan LogMessage)
		// Passing through target PORTs in threaded slice
		for _, target := range targets[slicestart : slicestart+threads] {
			// Increment and checking if we need to update slice start:end values
			increment++
			if increment == (slicestart + threads) {
				slicestart = increment
			}
			// Asynchronous call for the Dial function into channels.
			// Temporarily its string for logging purposes.
			// Will be map[string][]string.
			go scannerResult.doNVDDial(target, verbose, ch)
		}

		// Awaiting promised requests and logging all our channels
		for i := 0; i < threads; i++ {
			printChannelData(ch)
		}
		close(ch)
		if scannerResult.IP != "" {
			res = append(res, scannerResult)
			scannerResult = ScanReport{}
		}
		if (increment + threads) > len(targets) {
			if (increment+divisionleft) > len(targets) || divisionleft == 0 {
				break
			}
			threads = divisionleft
		}
	}
	// 'return nil' here is for test purposes only. Will be tested "in the field".
	// After "field" tests will pack it to a 'map[string][]string' and will return for
	// the CVEs/CPEs/CWEs processor for an analysis.
	return res, nil
}
