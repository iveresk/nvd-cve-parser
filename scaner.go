package main

import (
	"bufio"
	"io"
	"log"
	"net"
	"os"
	"strings"
	"time"
)

func printChannelData(ch chan string) {
	// Logging is for test purposes only. Will be tested "in the field".
	// After "field" tests will pack it to a 'map[string][]string' and will return for
	// the CVEs/CPEs/CWEs processor for an analysis.
	log.Println(<-ch)
}

func doNVDDial(url, port string, ch chan string) {
	// Defining basic vars for clearance and making code more readable
	target := url + ":" + port
	protocol := "tcp"
	dialtimeout := 350 * time.Millisecond
	service := "ssh"
	logspace := "\t"
	conn, err := net.DialTimeout(protocol, target, dialtimeout)
	if err != nil {
		ch <- "Nothing in for the " + target
		return
	}
	defer conn.Close()
	service = readServices(port, protocol)
	br := bufio.NewReader(conn)
	banner := make([]byte, 256)
	n, berr := io.ReadFull(br, banner)
	if berr != nil {
		banner = []byte("No banner")
	} else {
		banner = banner[:n]
	}
	// Logging is for test purposes only. Will be tested "in the field".
	// After "field" tests will pack it to a 'map[string][]string' and will return for
	// the CVEs/CPEs/CWEs processor for an analysis.
	ch <- url + logspace + port + logspace + "opened" + logspace + service + logspace + string(banner)
}

func readServices(port, protocol string) string {
	service := "No Service"
	expression := "([a-z|-]){1,32}[\\t|.]" + port + "/" + protocol
	readfile, err := os.ReadFile("./assets/nmap-services.txt")
	if err != nil {
		log.Fatal("There is no file ./assets/nmap-services.txt")
	}
	services := string(readfile)
	for _, regex := range checkRegexp(expression, services) {
		service = strings.Split(string(regex), "\t")[0]
	}
	return service
}

func scanDeviceTarget(threads int, input ...[]string) error {
	// TODO refactor it for the map[string][]string, error
	// Defining basic vars for clearance and making code more readable
	urls := input[0]
	ports := input[1]
	var ch chan string
	// Defining thread working variables to slice our port array properly
	slicestart := 0
	increment := 0
	// Check if ports count is less than threads
	if len(ports) < threads {
		threads = len(ports)
	}
	// Passing through target URLs through the array
	for _, url := range urls {
		// One channel for the target
		ch = make(chan string)
		defer close(ch)
		log.Println("Scanning target " + url)
		// Wrapper loop to range through the correct incremented slice values
		for {
			// Passing through target PORTs in threaded slice
			for _, port := range ports[slicestart : slicestart+threads] {
				// Increment and checking if we need to update slice start:end values
				increment++
				if increment == (slicestart + threads) {
					slicestart = increment
				}
				// Asynchronous call for the Dial function into channels.
				// Temporarily its string for logging purposes.
				// Will be map[string][]string.
				go doNVDDial(url, port, ch)
				//printChannelData(ch)
			}
			// Awaiting promised requests and logging all our channels
			for i := 0; i < threads; i++ {
				printChannelData(ch)
			}
			if (increment + threads) > len(ports) {
				break
			}
		}
	}
	// 'return nil' here is for test purposes only. Will be tested "in the field".
	// After "field" tests will pack it to a 'map[string][]string' and will return for
	// the CVEs/CPEs/CWEs processor for an analysis.
	return nil
}
