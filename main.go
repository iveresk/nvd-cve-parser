package main

import (
	"flag"
	"log"
	"os"
	"strconv"
)

func main() {
	mode := flag.String("m", "", "Mode of the tool usage defining the algo of it.")
	// TODO change it for the free string with params
	url := flag.String("u", "", "Target URL for the scan in the IPv4 format")
	port := flag.String("p", "80", "Target ports for the scan")
	threads := flag.Int("t", 5, "The count of threads")
	verbose := flag.Bool("v", false, "Flag of verbose level. False for production, True for debugging")
	flag.Parse()
	// Setting up the default mode usage for scanning network devices for CVEs
	// in a case that nothing was settled for the run
	if *mode == "" {
		*mode = "filljson"
	}
	// main algo is described here
	var devices Devices
	var m LogMessage
	// chasing mode case to define the model of behavior and collection of API calls for JSON(s) update.
	switch *mode {
	case "filljson":
		devices = readDevices()
		// Filling our local JSON files with NVD Data
		// !NOTE, the DB is OLD and format changed dramatically, so not all JSON is Unmarshalled
		var json []byte
		for _, device := range devices.devices["devices"] {
			json = findKeyword(device)
			write := writeToFile(device, json)
			if write != nil {
				m.Message = "Can not write to JSON file"
				m.MessageType = "fatal"
				m.getLogger()
			}
		}
		log.Println("The JSON files for the devices are successfully created")
	case "savexlxs":
		devices = readDevices()
		var gluedjson []NVDRequest
		for _, device := range devices.devices["devices"] {
			cvejson := readJSON(device)
			// Read JSON and Data collection methods for XLXS file are made not in an optimal form
			// for the file creation requiring lots of unnecessary actions.
			// It is made because of next more important operations for the libraries' assessment
			gluedjson = append(gluedjson, cvejson)
		}
		// Writing glued JSON to XLXS file
		err := writetoXLXS(gluedjson, devices)
		if err != nil {
			log.Println("Can not write to the XLXS file report")
			log.Println(err)
		}
	case "scanner":
		var urls, ports []string
		var json []byte
		urls = processFlags(*url)
		// Checking for the Fatal pattern for the scanner.
		// If there is no target IP for the scanner
		if urls[0] == "" {
			m.Message = "Critical issue. Please specify the IP"
			m.MessageType = "helper"
			m.getLogger()
		}
		// Erasing non IPv4 IPs from the parameter line
		urls = processRegExp(urls)
		if urls[0] == "" {
			m.Message = "No Valid IPv4 was in parameters. Please specify the IP"
			m.MessageType = "helper"
			m.getLogger()
		}
		// Processing the collection of ports from the command line
		ports = processFlags(*port)
		// Processing the use-case when we used 'top' command and
		// Grabbing nmap top 1000 ports for the scan
		if ports[0] == "top" {
			topports, err := os.ReadFile("./assets/ports.txt")
			if err != nil {
				m.Message = "There is no file ./assets/ports.txt"
				m.MessageType = "fatal"
				m.getLogger()
			}
			ports = processPorts(string(topports))
		}
		scannedreports, err := scanDeviceTarget(*threads, *verbose, urls, ports)
		if err != nil {
			log.Println("Scanner failed")
		}
		var keyword string
		for _, scannedvuln := range scannedreports.Vuln {
			if scannedvuln.VPort.Banner == "No banner" {
				if scannedvuln.VPort.Service != "No Service" {
					// Making keyword as service (port function) to find
					keyword = scannedvuln.VPort.Service
				} else {
					m.Message = "There is no vulnerability for this port as there is no a banner and a service :("
					m.MessageType = "regular"
					m.getLogger()
				}
				// Making device as a service
				// TODO Parse Device and Firmware From the Banner
			}
			// Reading and forming a request by service
			// Here I am assuming that ports and services there will be
			// Much and much more than we have 'devices' in our 'assets/keywords.json' file
			json = findKeyword(keyword)
			write := writeToFile(keyword, json)
			if write != nil {
				m.Message = "Can not write to JSON file"
				m.MessageType = "fatal"
				m.getLogger()
			}
			// Reading and parsing the JSON for Service Vulnerability
			cvejson := readJSON(keyword)
			// Pre-processing json data to receive firmware to compare
			preprocess := preProcessNVD(cvejson, keyword)
			// Writing the Data
			for i, _ := range cvejson.Vulnerabilities {
				sfirm, serr := strconv.ParseFloat(scannedvuln.VFirm.Firmware, 64)
				rfirm, ferr := strconv.ParseFloat(preprocess[2], 64)
				if serr != nil || ferr != nil {
					m.Message = "Some of firmwares are impossible to convert to float32 and compare"
					m.MessageType = "fatal"
					m.getLogger()
				}
				if sfirm <= rfirm {
					scannedvuln.CVEID = cvejson.Vulnerabilities[i].CVEs.ID
					for j, _ := range cvejson.Vulnerabilities[i].CVEs.References {
						scannedvuln.Link[j] = cvejson.Vulnerabilities[i].CVEs.References[j].URL
					}
				}
			}
		}
		scannedreports.logScanned()
	case "libtocwe":
		// TODO the main algo here for the scanning code, imports for CWEs
	case "update":
		// TODO update flow
	default:
		m.MessageType = "helper"
		m.getLogger()
	}
}
