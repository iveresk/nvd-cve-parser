package main

import (
	"flag"
	"log"
	"os"
	"strconv"
)

func main() {
	mode := flag.String("m", "", "Mode of the tool usage defining the algo of it.")
	url := flag.String("u", "", "Target URL for the scan in the IPv4 format")
	port := flag.String("p", "80", "Target ports for the scan")
	threads := flag.Int("t", 5, "The count of threads")
	network := flag.Bool("n", false, "Flag of network mode. False for 'local', True for 'internet''")
	verbose := flag.Bool("v", false, "Flag of verbose level. False for production, True for debugging")
	cveport := flag.Bool("cp", false, "Flag to scan CVEs/CPEs/CWEs by ports. False as the volume is huge")
	flag.Parse()
	// Setting up the default mode usage for scanning network devices for CVEs
	// in a case that nothing was settled for the run
	if *mode == "" {
		*mode = "filljson"
	}
	// main algo is described here
	var devices Devices
	var m LogMessage
	// chasing mode case to define the model of behavior and collection of API calls for JSON(s) update.
	switch *mode {
	case "filljson":
		// TODO make jsons for major ports and services
		devices = readDevices()
		// Filling our local JSON files with NVD Data
		// !NOTE, the DB is OLD and format changed dramatically, so not all JSON is Unmarshalled
		var json []byte
		for _, device := range devices.devices["devices"] {
			json = findKeyword(device)
			write := writeToFile(device, json)
			if write != nil {
				m.Message = "Can not write to JSON file"
				m.MessageType = "fatal"
				m.getLogger()
			}
		}
		for _, service := range devices.devices["services"] {
			json = findKeyword(service)
			write := writeToFile(service, json)
			if write != nil {
				m.Message = "Can not write to JSON file"
				m.MessageType = "fatal"
				m.getLogger()
			}
		}
		log.Println("The JSON files for the devices are successfully created")
	case "savexlxs":
		devices = readDevices()
		var gluedjson []NVDRequest
		for _, device := range devices.devices["devices"] {
			cvejson := readJSON(device)
			// Read JSON and Data collection methods for XLXS file are made not in an optimal form
			// for the file creation requiring lots of unnecessary actions.
			// It is made because of next more important operations for the libraries' assessment
			gluedjson = append(gluedjson, cvejson)
		}
		// Writing glued JSON to XLXS file
		err := writetoXLXS(gluedjson, devices)
		if err != nil {
			log.Println("Can not write to the XLXS file report")
			log.Println(err)
		}
	case "scanner":
		var urls, ports []string
		var json []byte
		urls = processFlags(*url)
		// Checking for the Fatal pattern for the scanner.
		// If there is no target IP for the scanner
		if urls[0] == "" {
			m.Message = "Critical issue. Please specify the IP"
			m.MessageType = "helper"
			m.getLogger()
		}
		// Erasing non IPv4 IPs from the parameter line
		urls = processRegExp(urls)
		if urls[0] == "" {
			m.Message = "No Valid IPv4 was in parameters. Please specify the IP"
			m.MessageType = "helper"
			m.getLogger()
		}
		// Processing the collection of ports from the command line
		ports = processFlags(*port)
		// Processing the use-case when we used 'top' command and
		// Grabbing nmap top 1000 ports for the scan
		if ports[0] == "top" {
			topports, err := os.ReadFile("./assets/ports.txt")
			if err != nil {
				m.Message = "There is no file ./assets/ports.txt"
				m.MessageType = "fatal"
				m.getLogger()
			}
			ports = processPorts(string(topports))
		}
		scannedreports, err := scanDeviceTarget(*threads, *verbose, urls, ports)
		if err != nil {
			log.Println("Scanner failed")
		}
		var keyword string
		for r, _ := range scannedreports {
			for k, _ := range scannedreports[r].Vuln {
				if scannedreports[r].Vuln[k].VPort.Banner == "No banner" {
					if !*cveport {
						break
					}
					if scannedreports[r].Vuln[k].VPort.Service != "No Service" {
						// Making keyword as service (port function) to find
						keyword = scannedreports[r].Vuln[k].VPort.Service
					} else {
						m.Message = "There is no vulnerability for this port as there is no a banner and a service :("
						m.MessageType = "regular"
						m.getLogger()
					}
					// Making device as a service
					// TODO Parse Device and Firmware From the Banner
				}
				if *network {
					// Reading and forming a request by service
					// Here I am assuming that ports and services there will be
					// Much and much more than we have 'devices' in our 'assets/keywords.json' file
					json = findKeyword(keyword)
					write := writeToFile(keyword, json)
					if write != nil {
						m.Message = "Can not write to JSON file"
						m.MessageType = "fatal"
						m.getLogger()
					}
				}
				// Reading and parsing the JSON for Service Vulnerability
				cvejson := readJSON(keyword)
				// Pre-processing json data to receive firmware to compare
				preprocess := preProcessNVD(cvejson, keyword)
				// Writing the Data
				step := 0
				for i, _ := range cvejson.Vulnerabilities {
					sfirm, _ := strconv.ParseFloat(scannedreports[r].Vuln[k].VFirm.Firmware, 64)
					rfirm, ferr := strconv.ParseFloat(preprocess[step+4], 64)
					step += 7
					if ferr != nil {
						m.Message = "Some of firmwares are impossible to convert to float32 and compare"
						m.MessageType = "fatal"
						m.getLogger()
					}
					if sfirm > rfirm {
						continue
					}
					scannedreports[r].Vuln[k].CVEID = cvejson.Vulnerabilities[i].CVEs.ID
					for j, _ := range cvejson.Vulnerabilities[i].CVEs.References {
						scannedreports[r].Vuln[k].Link = append(scannedreports[r].Vuln[k].Link, cvejson.Vulnerabilities[i].CVEs.References[j].URL)
					}
					scannedreports[r].logScanned()
				}
			}
		}

	case "libtocwe":
		// TODO the main algo here for the scanning code, imports for CWEs
	case "update":
		// TODO update flow
	default:
		m.MessageType = "helper"
		m.getLogger()
	}
}
