package main

import (
	"flag"
	"log"
)

func main() {
	mode := flag.String("m", "", "Mode of the tool usage defining the algo of it.")
	url := flag.String("u", "", "Target URL for the scan in the IPv4 format")
	port := flag.String("p", "80", "Target ports for the scan")
	threads := flag.Int("t", 3, "The count of threads")
	network := flag.Bool("n", false, "Flag of network mode. False for 'local', True for 'internet''")
	verbose := flag.Bool("v", false, "Flag of verbose level. False for production, True for debugging")
	portCVE := flag.Bool("cp", false, "Flag to scan CVEs/CPEs/CWEs by ports. False as the volume is huge")
	reportLevel := flag.Int("r", 5, "The count of CVEs for one report per socket")
	flag.Parse()
	// Setting up the default mode usage for scanning network keywords for CVEs
	// in a case that nothing was settled for the run
	if *mode == "" {
		*mode = "filljson"
	}
	// main algo is described here
	var devices Devices
	var cveJSON NVDRequest
	var m LogMessage
	// chasing mode case to define the model of behavior and collection of API calls for JSON(s) update.
	switch *mode {
	case "filljson":
		devices.readJSON("keywords")
		// Filling our local JSON files with NVD Data
		// !NOTE, the DB is OLD and format changed dramatically, so not all JSON is Unmarshalled
		var json []byte
		for _, device := range devices.keywords["devices"] {
			json = findKeyword(device)
			write := writeToFile(device, json)
			if write != nil {
				m.Message = "Can not write to JSON file"
				m.MessageType = "fatal"
				m.getLogger()
			}
		}
		// Unmarshal and filling JSON files
		for _, service := range devices.keywords["services"] {
			json = findKeyword(service)
			write := writeToFile(service, json)
			if write != nil {
				m.Message = "Can not write to JSON file"
				m.MessageType = "fatal"
				m.getLogger()
			}
		}
		log.Println("The JSON files for the keywords are successfully created")
	case "savexlxs":
		devices.readJSON("keywords")
		var gluedJSON []NVDRequest
		for _, device := range devices.keywords["devices"] {
			cveJSON.readJSON(device)
			// Read JSON and Data collection methods for XLXS file are made not in an optimal form
			// for the file creation requiring lots of unnecessary actions.
			// It is made because of next more important operations for the libraries' assessment
			gluedJSON = append(gluedJSON, cveJSON)
		}
		// Writing glued JSON to XLXS file
		err := writetoXLXS(gluedJSON, devices)
		if err != nil {
			log.Println("Can not write to the XLXS file report")
			log.Println(err)
		}
	case "scanner":
		var urls, ports []string
		urls = processFlags(*url, ",")
		// Checking for the Fatal pattern for the scanner.
		// If there is no target IP for the scanner
		if urls[0] == "" {
			m.Message = "Critical issue. Please specify the IP"
			m.MessageType = "helper"
			m.getLogger()
		}
		// Erasing non IPv4 IPs from the parameter line
		urls = processRegExp(urls)
		if urls[0] == "" {
			m.Message = "No Valid IPv4 was in parameters. Please specify the IP"
			m.MessageType = "helper"
			m.getLogger()
		}
		// Processing the collection of ports from the command line
		ports = processFlags(*port, ",")
		// Processing the use-case when we used 'top' command and
		// Grabbing nmap top 1000 ports for the scan
		if ports[0] == "top" {
			topports := openFile("./assets/ports.json")
			ports = processFlags(string(topports), "\n")
		}
		scannedReports, err := scanDeviceTarget(*threads, *verbose, urls, ports)
		if err != nil {
			log.Println("Scanner failed")
		}
		processBanners(scannedReports, *network, *portCVE, *verbose, *reportLevel)

	case "libtocwe":
		// TODO the main algo here for the scanning code, imports for CWEs
	case "update":
		// TODO update flow
	default:
		m.MessageType = "helper"
		m.getLogger()
	}
}
