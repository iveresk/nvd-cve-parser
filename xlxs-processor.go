package main

import (
	"fmt"
	"github.com/360EntSecGroup-Skylar/excelize"
	"strconv"
	"time"
)

func ReturnCellLetter(index int) string {
	// !Note, this system isn't support wide sheets
	// Width is limited by 26 rows.
	// Do not support double indexes as 'AB'
	if index > 26 { // English alphabet count
		index = 0
	}
	return string(rune('A' + index))
}

func PreProcessNVD(cvejson NVDRequest, device string) []string {
	// Defining variables to have a complex check
	var result []string
	var device_mark string
	var reference_mark string
	var description_mark string
	var exploit_score string

	for i := 0; i < cvejson.ResultsPerPage; i++ {
		// Checking the Data on structure and on integrity
		if len(cvejson.Vulnerabilities) == 0 {
			continue
		}
		if cvejson.Vulnerabilities == nil ||
			cvejson.Vulnerabilities[i].CVEs.Metrics.CvssMetricsV2 == nil ||
			cvejson.Vulnerabilities[i].CVEs.Descriptions == nil ||
			cvejson.Vulnerabilities[i].CVEs.References == nil ||
			cvejson.Vulnerabilities[i].CVEs.Configurations == nil ||
			cvejson.Vulnerabilities[i].CVEs.Configurations[0].Nodes == nil ||
			cvejson.Vulnerabilities[i].CVEs.Configurations[0].Nodes[0].CpeMatch == nil {
			continue
		}
		// Checking on integrity of the data in DB
		if len(cvejson.Vulnerabilities[i].CVEs.References) == 0 {
			reference_mark = "Nothing here in DB"
		} else {
			reference_mark = cvejson.Vulnerabilities[i].CVEs.References[0].URL
		}
		if len(cvejson.Vulnerabilities[i].CVEs.Descriptions) == 0 {
			description_mark = "Nothing here in DB"
		} else {
			description_mark = cvejson.Vulnerabilities[i].CVEs.Descriptions[0].Value
		}

		if len(cvejson.Vulnerabilities[i].CVEs.Metrics.CvssMetricsV2) == 0 {
			exploit_score = "Nothing here in DB"
		} else {
			exploit_score = fmt.Sprintf("%f", cvejson.Vulnerabilities[i].CVEs.Metrics.CvssMetricsV2[0].ExploitabilityScore)
		}
		// TODO Think on how to devide device from firmware for different devices.
		// Checking if our device mark is not empty
		if cvejson.Vulnerabilities[i].CVEs.Configurations[0].Nodes[0].CpeMatch[0].Criteria == "" {
			device_mark = "Nothing here in DB"
		} else {
			device_mark = cvejson.Vulnerabilities[i].CVEs.Configurations[0].Nodes[0].CpeMatch[0].Criteria
		}
		result = append(result,
			device,
			device_mark,
			cvejson.Vulnerabilities[i].CVEs.ID,
			exploit_score,
			description_mark,
			reference_mark)
	}
	return result
}

func writetoXLXS(resjson []NVDRequest, devices Devices) error {
	var cell string
	var fillxlxs []string
	var device string
	// step for column filler
	step := 6

	// Appending Data in needed format.
	// It was made as absolutely not optimal thing to glue a file in a format
	// needed for the customer.
	for i, cvejson := range resjson {
		for j, data := range devices.devices["devices"] {
			if i == j {
				device = data
			}
		}
		// Creating collection only with viable data
		datas := PreProcessNVD(cvejson, device)
		for _, data := range datas {
			fillxlxs = append(fillxlxs, data)
		}
	}
	// Creating XLXS file
	fxlxs := excelize.NewFile()
	// Create a new sheet.
	activesheet := fxlxs.NewSheet("Database")
	//Deleting Default sheet
	fxlxs.DeleteSheet("Sheet1")
	//Making the Header, setting up styles for it.
	style, err := fxlxs.NewStyle(`{"font":{"bold":true}}`)
	if err != nil {
		fmt.Println(err)
	}
	fxlxs.SetCellStyle("Database", "A1", "F1", style)
	fxlxs.SetColWidth("Sheet1", "A", "H", 150)
	fxlxs.SetCellValue("Database", "A1", "Device Name")
	fxlxs.AutoFilter("Database", "A1", "F1", "")
	fxlxs.SetCellValue("Database", "B1", "Device Model, Firmware")
	fxlxs.SetCellValue("Database", "C1", "CVE ID")
	fxlxs.SetCellValue("Database", "D1", "Exploit Score")
	fxlxs.SetCellValue("Database", "E1", "Detailed Description")
	fxlxs.SetCellValue("Database", "F1", "References, URL")
	// Set value of a cell.
	j := 0
	for i, data := range fillxlxs {
		if j%step == 0 {
			j = 0
		}
		// marking cell to be filled
		cell = ReturnCellLetter(j) + strconv.Itoa(i/step+2) // 2 cause we have the Header
		fxlxs.SetCellValue("Database", cell, data)
		j++
	}
	// Set active sheet of the workbook.
	fxlxs.SetActiveSheet(activesheet)
	// Save spreadsheet by the given path.
	err = fxlxs.SaveAs("./output/CVEs-db" + time.Now().Format("01-02-2006") + ".xlsx")
	if err != nil {
		return err
	}
	return nil
}
