package main

import (
	"fmt"
	"github.com/360EntSecGroup-Skylar/excelize"
	"log"
	"regexp"
	"strconv"
	"strings"
	"time"
)

func checkRegexp(regexpression, inputstring string) [][]byte {
	re, err := regexp.Compile(regexpression)
	if err != nil {
		log.Fatal("Regexp is invalid can not regexp.Compile it.")
	}
	return re.FindAll([]byte(inputstring), -1)
}

func getModelVersion(inputs ...string) (string, string) {
	var model, version string
	regexps := []string{"([0-9]\\.){1,3}[0-9]+"}
	for _, input := range inputs {
		devices := strings.Split(input, ":")
		if devices == nil {
			log.Println("Check devices input")
		}
		if len(devices) == 1 || len(devices) == 2 || len(devices) == 3 || len(devices) == 4 {
			for _, exp := range regexps {
				for _, regex := range checkRegexp(exp, input) {
					version += string(regex) + " "
				}
			}
		} else {
			model = devices[4] + " "
			if devices[5] == "*" {
				continue
			}
			if checkRegexp(regexps[0], devices[5]) != nil {
				continue
			}
			model += devices[5] + " "
		}
	}

	return model, version
}

func returnCellLetter(index int) string {
	// !Note, this system isn't support wide sheets
	// Width is limited by 26 rows.
	// Do not support double indexes as 'AB'
	if index > 26 { // English alphabet count
		index = 0
	}
	return string(rune('A' + index))
}

func preProcessNVD(cvejson NVDRequest, device string) []string {
	// Defining variables to have a complex check
	var result []string
	var device_mark string
	var vuln_version string
	var reference_mark string
	var description_mark string
	var exploit_score string

	for i := 0; i < cvejson.ResultsPerPage; i++ {
		// Checking the Data on structure and on integrity
		if len(cvejson.Vulnerabilities) == 0 {
			continue
		}
		if cvejson.Vulnerabilities == nil ||
			cvejson.Vulnerabilities[i].CVEs.Metrics.CvssMetricsV2 == nil ||
			cvejson.Vulnerabilities[i].CVEs.Descriptions == nil ||
			cvejson.Vulnerabilities[i].CVEs.References == nil ||
			cvejson.Vulnerabilities[i].CVEs.Configurations == nil ||
			cvejson.Vulnerabilities[i].CVEs.Configurations[0].Nodes == nil ||
			cvejson.Vulnerabilities[i].CVEs.Configurations[0].Nodes[0].CpeMatch == nil {
			continue
		}
		// Checking on integrity of the data in DB
		if len(cvejson.Vulnerabilities[i].CVEs.References) == 0 {
			reference_mark = "Nothing here in DB"
		} else {
			reference_mark = cvejson.Vulnerabilities[i].CVEs.References[0].URL
		}
		if len(cvejson.Vulnerabilities[i].CVEs.Descriptions) == 0 {
			description_mark = "Nothing here in DB"
		} else {
			description_mark = cvejson.Vulnerabilities[i].CVEs.Descriptions[0].Value
		}

		if len(cvejson.Vulnerabilities[i].CVEs.Metrics.CvssMetricsV2) == 0 {
			exploit_score = "Nothing here in DB"
		} else {
			exploit_score = fmt.Sprintf("%f", cvejson.Vulnerabilities[i].CVEs.Metrics.CvssMetricsV2[0].ExploitabilityScore)
		}
		// Checking if our device mark is not empty
		if cvejson.Vulnerabilities[i].CVEs.Configurations[0].Nodes[0].CpeMatch[0].Criteria == "" {
			device_mark = "Nothing here in DB"
		} else {
			device_mark = cvejson.Vulnerabilities[i].CVEs.Configurations[0].Nodes[0].CpeMatch[0].Criteria
		}
		// Parsing strings from DB to grab Model and Firmwares that are vulnarable
		// for the CVEs, CPEs, CWEs.
		device_mark, vuln_version = getModelVersion(device_mark, description_mark)
		result = append(result,
			device,
			device_mark,
			vuln_version,
			cvejson.Vulnerabilities[i].CVEs.ID,
			exploit_score,
			description_mark,
			reference_mark)
	}
	return result
}

func writetoXLXS(resjson []NVDRequest, devices Devices) error {
	var cell string
	var fillxlxs []string
	var device string
	// step for column filler
	step := 7

	// Appending Data in needed format.
	// It was made as absolutely not optimal thing to glue a file in a format
	// needed for the customer.
	for i, cvejson := range resjson {
		for j, data := range devices.devices["devices"] {
			if i == j {
				device = data
			}
		}
		// Creating collection only with viable data
		datas := preProcessNVD(cvejson, device)
		for _, data := range datas {
			fillxlxs = append(fillxlxs, data)
		}
	}
	// Creating XLXS file
	fxlxs := excelize.NewFile()
	// Create a new sheet.
	activesheet := fxlxs.NewSheet("Database")
	//Deleting Default sheet
	fxlxs.DeleteSheet("Sheet1")
	//Making the Header, setting up styles for it.
	style, err := fxlxs.NewStyle(`{"font":{"bold":true}}`)
	if err != nil {
		fmt.Println(err)
	}
	fxlxs.SetCellStyle("Database", "A1", "G1", style)
	fxlxs.SetColWidth("Sheet1", "A1", "G1", 40)
	fxlxs.SetCellValue("Database", "A1", "Device Name")
	fxlxs.AutoFilter("Database", "A1", "F1", "")
	fxlxs.SetCellValue("Database", "B1", "Device Model")
	fxlxs.SetCellValue("Database", "C1", "Vulnerable Firmware (lower & incl.)")
	fxlxs.SetCellValue("Database", "D1", "CVE ID")
	fxlxs.SetCellValue("Database", "E1", "Exploit Score")
	fxlxs.SetCellValue("Database", "F1", "Detailed Description")
	fxlxs.SetCellValue("Database", "G1", "References, URL")
	// Set value of a cell.
	j := 0
	for i, data := range fillxlxs {
		if j%step == 0 {
			j = 0
		}
		// marking cell to be filled
		cell = returnCellLetter(j) + strconv.Itoa(i/step+2) // 2 cause we have the Header
		fxlxs.SetCellValue("Database", cell, data)
		j++
	}
	// Set active sheet of the workbook.
	fxlxs.SetActiveSheet(activesheet)
	// Save spreadsheet by the given path.
	err = fxlxs.SaveAs("./output/CVEs-db" + time.Now().Format("01-02-2006") + ".xlsx")
	if err != nil {
		return err
	}
	return nil
}
