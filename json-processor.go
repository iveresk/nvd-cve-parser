package main

import (
	"encoding/json"
	"fmt"
	"log"
	"os"
	"regexp"
	"strings"
)

type Devices struct {
	keywords map[string][]string
}

type NVDRequest struct {
	ResultsPerPage  int             `json:"resultsPerPage"`
	StartIndex      int             `json:"startIndex"`
	TotalResults    int             `json:"totalResults"`
	Format          string          `json:"format"`
	Version         string          `json:"version"`
	Timestamp       string          `json:"timestamp"`
	Vulnerabilities []Vulnerability `json:"vulnerabilities"`
}

type Vulnerability struct {
	CVEs CVE `json:"cve"`
}

type CVE struct {
	ID               string          `json:"id"`
	SourceIdentifier string          `json:"sourceIdentifier"`
	Published        string          `json:"published"`
	LastModified     string          `json:"lastModified"`
	VulnStatus       string          `json:"vulnStatus"`
	Descriptions     []Description   `json:"descriptions"`
	Metrics          Metric          `json:"metrics"`
	Weaknesses       []Weakness      `json:"weaknesses"`
	Configurations   []Configuration `json:"configurations"`
	References       []Reference     `json:"references"`
}

type Metric struct {
	CvssMetricsV2 []CVSSMetricsV2 `json:"cvssMetricV2"`
}

type CVSSMetricsV2 struct {
	Source                  string   `json:"source"`
	Type                    string   `json:"type"`
	cvssData                CVSSData `json:"cvssData"`
	ExploitabilityScore     float64  `json:"exploitabilityScore"`
	ImpactScore             float64  `json:"impactScore"`
	AcInsufInfo             bool     `json:"acInsufInfo"`
	ObtainAllPrivilege      bool     `json:"obtainAllPrivilege"`
	ObtainUserPrivilege     bool     `json:"obtainUserPrivilege"`
	ObtainOtherPrivilege    bool     `json:"obtainOtherPrivilege"`
	UserInteractionRequired bool     `json:"userInteractionRequired"`
}

type CVSSData struct {
	Version               string  `json:"version"`
	VectorString          string  `json:"vectorString"`
	AccessVector          string  `json:"accessVector"`
	AccessComplexity      string  `json:"accessComplexity"`
	Authentication        string  `json:"authentication"`
	ConfidentialityImpact string  `json:"confidentialityImpact"`
	IntegrityImpact       string  `json:"integrityImpact"`
	AvailabilityImpact    string  `json:"availabilityImpact"`
	BaseScore             float64 `json:"baseScore"`
	BaseSeverity          string  `json:"baseSeverity"`
}

type Weakness struct {
	Source      string        `json:"source"`
	Type        string        `json:"type"`
	Description []Description `json:"description"`
}

type Configuration struct {
	Nodes []Node `json:"nodes"`
}

type Reference struct {
	URL    string   `json:"url"`
	Source string   `json:"source"`
	Tags   []string `json:"tags,omitempty"`
}

type Description struct {
	Lang  string `json:"lang"`
	Value string `json:"value"`
}

type Node struct {
	Operator string     `json:"operator"`
	Negate   bool       `json:"negate"`
	CpeMatch []CPEMatch `json:"cpeMatch"`
}

type CPEMatch struct {
	Vulnerable          bool   `json:"vulnerable"`
	Criteria            string `json:"criteria"`
	VersionEndIncluding string `json:"versionEndIncluding"`
	MatchCriteriaID     string `json:"matchCriteriaId"`
}

type reader interface {
	readJSON(assets string)
}

func openFile(filepath string) []byte {
	var m LogMessage
	// reading the device-keywords.json file
	dcontent, err := os.ReadFile(filepath)
	if err != nil {
		m.MessageType = "regular"
		m.Message = "There is no file " + filepath
		m.getLogger()
	}
	return dcontent
}

func (devices *Devices) readJSON(assets string) {
	var m LogMessage
	filepath := "./assets/" + assets + ".json"
	dcontent := openFile(filepath)
	err := json.Unmarshal(dcontent, &devices.keywords)
	if err != nil || &devices.keywords == nil {
		m.MessageType = "regular"
		m.Message = "Check if the file " + filepath + ".json is in json format"
		m.getLogger()
	}
}

func (nvdRequest *NVDRequest) readJSON(assets string) {
	var m LogMessage
	filepath := "./assets/" + assets + ".json"
	dcontent := openFile(filepath)
	err := json.Unmarshal(dcontent, &nvdRequest)
	if err != nil && nvdRequest.Vulnerabilities == nil {
		m.MessageType = "regular"
		m.Message = "Check if the file " + filepath + " is in json format"
		m.getLogger()
	}
}

func writeToFile(filename string, byte []byte) error {
	return os.WriteFile("./assets/"+filename+".json", byte, 0666)
}

func preProcessNVD(cvejson NVDRequest, device string) []string {
	// Defining variables to have a complex check
	var result []string
	var device_mark string
	var vuln_version string
	var reference_mark string
	var description_mark string
	var exploit_score string

	// TODO Make pagination for the processing
	for i := cvejson.ResultsPerPage - 1; i >= 0; i-- {
		// Checking the Data on structure and on integrity
		if len(cvejson.Vulnerabilities) == 0 {
			continue
		}
		if cvejson.Vulnerabilities == nil ||
			cvejson.Vulnerabilities[i].CVEs.Metrics.CvssMetricsV2 == nil ||
			cvejson.Vulnerabilities[i].CVEs.Descriptions == nil ||
			cvejson.Vulnerabilities[i].CVEs.References == nil ||
			cvejson.Vulnerabilities[i].CVEs.Configurations == nil ||
			cvejson.Vulnerabilities[i].CVEs.Configurations[0].Nodes == nil ||
			cvejson.Vulnerabilities[i].CVEs.Configurations[0].Nodes[0].CpeMatch == nil {
			continue
		}
		// Checking on integrity of the data in DB
		if len(cvejson.Vulnerabilities[i].CVEs.References) == 0 {
			reference_mark = "Nothing here in DB"
		} else {
			reference_mark = cvejson.Vulnerabilities[i].CVEs.References[0].URL
		}
		if len(cvejson.Vulnerabilities[i].CVEs.Descriptions) == 0 {
			description_mark = "Nothing here in DB"
		} else {
			description_mark = cvejson.Vulnerabilities[i].CVEs.Descriptions[0].Value
		}

		if len(cvejson.Vulnerabilities[i].CVEs.Metrics.CvssMetricsV2) == 0 {
			exploit_score = "Nothing here in DB"
		} else {
			if cvejson.Vulnerabilities[i].CVEs.Metrics.CvssMetricsV2[0].ExploitabilityScore < 7.0 {
				continue
			}
			exploit_score = fmt.Sprintf("%5.2f", cvejson.Vulnerabilities[i].CVEs.Metrics.CvssMetricsV2[0].ExploitabilityScore)
		}
		// Checking if our device mark is not empty
		if cvejson.Vulnerabilities[i].CVEs.Configurations[0].Nodes[0].CpeMatch[0].Criteria == "" {
			device_mark = "Nothing here in DB"
		} else {
			device_mark = cvejson.Vulnerabilities[i].CVEs.Configurations[0].Nodes[0].CpeMatch[0].Criteria
		}
		// Parsing strings from DB to grab Model and Firmwares that are vulnarable
		// for the CVEs, CPEs, CWEs.
		device_mark, vuln_version = getModelVersion(device_mark, description_mark)
		// But if we have versions in DB already parsed - it's better, so we re-writing it
		if cvejson.Vulnerabilities[i].CVEs.Configurations[0].Nodes[0].CpeMatch[0].VersionEndIncluding != "" {
			vuln_version = cvejson.Vulnerabilities[i].CVEs.Configurations[0].Nodes[0].CpeMatch[0].VersionEndIncluding
		}
		result = append(result,
			device,
			device_mark,
			vuln_version,
			cvejson.Vulnerabilities[i].CVEs.ID,
			exploit_score,
			description_mark,
			reference_mark)
	}
	return result
}

func checkRegexp(regexpression, inputstring string) [][]byte {
	// Checking input string on the regular expression
	var m LogMessage
	re, err := regexp.Compile(regexpression)
	if err != nil {
		m.MessageType = "regular"
		m.Message = "Regexp is invalid can not regexp.Compile it."
		m.getLogger()
	}
	return re.FindAll([]byte(inputstring), -1)
}

func getModelVersion(inputs ...string) (string, string) {
	// Parsing the version from CPE-vector string in a case of VersionEndIncluding is Empty
	var model, version string
	regexps := []string{"([0-9]+\\.){1,3}[0-9]+"}
	for _, input := range inputs {
		devices := strings.Split(input, ":")
		if devices == nil || devices[0] == "" {
			log.Println("Check keywords input")
		}
		if len(devices) == 1 || len(devices) == 2 || len(devices) == 3 || len(devices) == 4 {
			for _, exp := range regexps {
				for _, regex := range checkRegexp(exp, input) {
					version += string(regex) + " "
				}
			}
		} else {
			if len(devices) == 5 {
				model = devices[4] + " "
			} else {
				if devices[5] == "*" {
					continue
				}
				if checkRegexp(regexps[0], devices[5]) != nil {
					continue
				}
				model += devices[5] + " "
			}
		}
	}

	return model, version
}

func readServices(port, protocol string) string {
	// Processing Services with nmap Services file
	service := "No Service"
	expression := "([a-z|-]){1,32}[\\t|.]" + port + "/" + protocol
	readfile := openFile("./assets/nmap-services.json")
	services := string(readfile)
	for _, regex := range checkRegexp(expression, services) {
		service = strings.Split(string(regex), "\t")[0]
	}
	return service
}

func getBannerVersion(banner, device string) string {
	// Banner version RegExp as it used in NVDs
	v := ""
	regexps := "([0-9]+\\.){1,3}[0-9]+"
	// Processing HTML use-case to the case
	i := strings.Index(banner, "body")
	if i > 0 {
		banner = banner[i:]
	}
	// Processing regular case
	i = strings.Index(banner, device)
	banner = banner[i : i+len([]rune(device))+20]
	res := checkRegexp(regexps, banner)
	for _, r := range res {
		v = string(r)
	}
	return v
}

func processBanner(banner, device string) string {
	// Finding if there is any banner version is available
	version := "0.0"
	banner = strings.ToLower(banner)
	device = strings.ToLower(device)
	if strings.Contains(banner, device) {
		version = getBannerVersion(banner, device)
	}
	return version
}

func stringCompare(currv, vulnv string) int {
	// Default vars
	res := 0
	comparedlen := 0
	// Comparing and adding "0" symbols to compare strings
	if len(currv) == len(vulnv) {
		comparedlen = len(currv)
	}
	if len(currv) > len(vulnv) {
		comparedlen = len(currv)
		for i := 0; i < (len(currv) - len(vulnv)); i++ {
			vulnv += "0"
		}
	}
	if len(vulnv) > len(currv) {
		comparedlen = len(vulnv)
		for i := 0; i < (len(vulnv) - len(currv)); i++ {
			currv += "0"
		}
	}
	// Comparing strings til first biggest symbol
	for i := 0; i < comparedlen; i++ {
		if currv[i] > vulnv[i] {
			res = 1
			break
		}
		if vulnv[i] > currv[i] {
			res = -1
			break
		}
	}
	return res
}

func processBanners(scannedreports []ScanReport, network, cveport, verbose bool) {
	var keyword string
	var m LogMessage
	var devices Devices
	var cvejson NVDRequest
	for r := range scannedreports {
		for k := range scannedreports[r].Vuln {
			if scannedreports[r].Vuln[k].VPort.Banner == "No banner" {
				if !cveport {
					break
				}
				if scannedreports[r].Vuln[k].VPort.Service != "No Service" {
					// Making keyword as service (port function) to find
					keyword = scannedreports[r].Vuln[k].VPort.Service
				} else {
					m.Message = "There is no vulnerability for this port as there is no a banner and a service :("
					m.MessageType = "regular"
					m.getLogger()
				}
			} else {
				// Making device as a service
				devices.readJSON("keywords")
				for _, device := range devices.keywords["devices"] {
					version := processBanner(scannedreports[r].Vuln[k].VPort.Banner, device)
					if version == "" {
						keyword, scannedreports[r].Vuln[k].VFirm.Device = device, device
						continue
					}
					if version != "0.0" {
						keyword, scannedreports[r].Vuln[k].VFirm.Device = device, device
						scannedreports[r].Vuln[k].VFirm.Firmware = version
						break
					}
				}
			}
			// Checking our pre-set flag on local network environment
			if network {
				// Reading and forming a request by service
				// Here I am assuming that ports and services there will be
				// Much and much more than we have 'keywords' in our 'assets/keywords.json' file
				json := findKeyword(keyword)
				write := writeToFile(keyword, json)
				if write != nil && verbose {
					m.Message = "Can not write to JSON file"
					m.MessageType = "regular"
					m.getLogger()
				}
			}
			// Double-checking if all necessary data is available
			currentfirm := scannedreports[r].Vuln[k].VFirm.Firmware
			if keyword == "" || currentfirm == "" {
				continue
			}
			// Reading and parsing the JSON for Service Vulnerability
			cvejson.readJSON(keyword)
			// Pre-processing json data to receive firmware to compare
			preprocess := preProcessNVD(cvejson, keyword)

			// Writing the Data
			for i := 0; i < len(preprocess); i += 7 {
				vulnfirm := preprocess[i+2]
				res := stringCompare(currentfirm, vulnfirm)
				// Checking if we need to log the vulnerability
				if res < 0 {
					// Logging the CVEs (now its default logging system)
					scannedreports[r].Vuln[k].CVEID = preprocess[i+3]
					scannedreports[r].Vuln[k].Link = append(scannedreports[r].Vuln[k].Link, preprocess[i+6])
					scannedreports[r].logScanned()
				}
			}
		}
	}
}
