package main

import (
	"encoding/json"
	"fmt"
	"log"
	"os"
	"regexp"
	"strconv"
	"strings"
)

type Devices struct {
	devices map[string][]string
}

type NVDRequest struct {
	ResultsPerPage  int             `json:"resultsPerPage"`
	StartIndex      int             `json:"startIndex"`
	TotalResults    int             `json:"totalResults"`
	Format          string          `json:"format"`
	Version         string          `json:"version"`
	Timestamp       string          `json:"timestamp"`
	Vulnerabilities []Vulnerability `json:"vulnerabilities"`
}

type Vulnerability struct {
	CVEs CVE `json:"cve"`
}

type CVE struct {
	ID               string          `json:"id"`
	SourceIdentifier string          `json:"sourceIdentifier"`
	Published        string          `json:"published"`
	LastModified     string          `json:"lastModified"`
	VulnStatus       string          `json:"vulnStatus"`
	Descriptions     []Description   `json:"descriptions"`
	Metrics          Metric          `json:"metrics"`
	Weaknesses       []Weakness      `json:"weaknesses"`
	Configurations   []Configuration `json:"configurations"`
	References       []Reference     `json:"references"`
}

type Metric struct {
	CvssMetricsV2 []CVSSMetricsV2 `json:"cvssMetricV2"`
}

type CVSSMetricsV2 struct {
	Source                  string   `json:"source"`
	Type                    string   `json:"type"`
	cvssData                CVSSData `json:"cvssData"`
	ExploitabilityScore     float64  `json:"exploitabilityScore"`
	ImpactScore             float64  `json:"impactScore"`
	AcInsufInfo             bool     `json:"acInsufInfo"`
	ObtainAllPrivilege      bool     `json:"obtainAllPrivilege"`
	ObtainUserPrivilege     bool     `json:"obtainUserPrivilege"`
	ObtainOtherPrivilege    bool     `json:"obtainOtherPrivilege"`
	UserInteractionRequired bool     `json:"userInteractionRequired"`
}

type CVSSData struct {
	Version               string  `json:"version"`
	VectorString          string  `json:"vectorString"`
	AccessVector          string  `json:"accessVector"`
	AccessComplexity      string  `json:"accessComplexity"`
	Authentication        string  `json:"authentication"`
	ConfidentialityImpact string  `json:"confidentialityImpact"`
	IntegrityImpact       string  `json:"integrityImpact"`
	AvailabilityImpact    string  `json:"availabilityImpact"`
	BaseScore             float64 `json:"baseScore"`
	BaseSeverity          string  `json:"baseSeverity"`
}

type Weakness struct {
	Source      string        `json:"source"`
	Type        string        `json:"type"`
	Description []Description `json:"description"`
}

type Configuration struct {
	Nodes []Node `json:"nodes"`
}

type Reference struct {
	URL    string   `json:"url"`
	Source string   `json:"source"`
	Tags   []string `json:"tags,omitempty"`
}

type Description struct {
	Lang  string `json:"lang"`
	Value string `json:"value"`
}

type Node struct {
	Operator string     `json:"operator"`
	Negate   bool       `json:"negate"`
	CpeMatch []CPEMatch `json:"cpeMatch"`
}

type CPEMatch struct {
	Vulnerable          bool   `json:"vulnerable"`
	Criteria            string `json:"criteria"`
	VersionEndIncluding string `json:"versionEndIncluding"`
	MatchCriteriaID     string `json:"matchCriteriaId"`
}

func readDevices() Devices {
	var m LogMessage
	filepath := "./assets/keywords.json"
	// reading the device-keywords.json file
	dcontent, err := os.ReadFile(filepath)
	if err != nil {
		m.MessageType = "regular"
		m.Message = "There is no file " + filepath
		m.getLogger()
	}
	var devices Devices
	err = json.Unmarshal(dcontent, &devices.devices)
	if err != nil || &devices.devices == nil {
		m.MessageType = "regular"
		m.Message = "Check if the file " + filepath + " is in json format"
		m.getLogger()
	}
	return devices
}

func readJSON(device string) NVDRequest {
	var m LogMessage
	filepath := "./assets/" + device + ".json"
	dcontent, err := os.ReadFile(filepath)
	if err != nil {
		m.Message = "There is no file " + filepath +
			"\n Try -n 'network' key to process the CVEs for the keyword"
		m.MessageType = "regular"
		m.getLogger()
	}
	var nvdRequest NVDRequest
	err = json.Unmarshal(dcontent, &nvdRequest)
	if err != nil && nvdRequest.Vulnerabilities == nil {
		m.MessageType = "regular"
		m.Message = "Check if the file " + filepath + " is in json format"
		m.getLogger()
	}
	if err != nil {
		log.Println("Not all the file " + filepath + " was processed")
		log.Println(err)
	}
	return nvdRequest
}

func writeToFile(filename string, byte []byte) error {
	return os.WriteFile("./assets/"+filename+".json", byte, 0666)
}

func preProcessNVD(cvejson NVDRequest, device string) []string {
	// Defining variables to have a complex check
	var result []string
	var device_mark string
	var vuln_version string
	var reference_mark string
	var description_mark string
	var exploit_score string

	// TODO Make pagination for the processing
	for i := cvejson.ResultsPerPage - 1; i >= 0; i-- {
		// Checking the Data on structure and on integrity
		if len(cvejson.Vulnerabilities) == 0 {
			continue
		}
		if cvejson.Vulnerabilities == nil ||
			cvejson.Vulnerabilities[i].CVEs.Metrics.CvssMetricsV2 == nil ||
			cvejson.Vulnerabilities[i].CVEs.Descriptions == nil ||
			cvejson.Vulnerabilities[i].CVEs.References == nil ||
			cvejson.Vulnerabilities[i].CVEs.Configurations == nil ||
			cvejson.Vulnerabilities[i].CVEs.Configurations[0].Nodes == nil ||
			cvejson.Vulnerabilities[i].CVEs.Configurations[0].Nodes[0].CpeMatch == nil {
			continue
		}
		// Checking on integrity of the data in DB
		if len(cvejson.Vulnerabilities[i].CVEs.References) == 0 {
			reference_mark = "Nothing here in DB"
		} else {
			reference_mark = cvejson.Vulnerabilities[i].CVEs.References[0].URL
		}
		if len(cvejson.Vulnerabilities[i].CVEs.Descriptions) == 0 {
			description_mark = "Nothing here in DB"
		} else {
			description_mark = cvejson.Vulnerabilities[i].CVEs.Descriptions[0].Value
		}

		if len(cvejson.Vulnerabilities[i].CVEs.Metrics.CvssMetricsV2) == 0 {
			exploit_score = "Nothing here in DB"
		} else {
			if cvejson.Vulnerabilities[i].CVEs.Metrics.CvssMetricsV2[0].ExploitabilityScore < 7.0 {
				continue
			}
			exploit_score = fmt.Sprintf("%5.2f", cvejson.Vulnerabilities[i].CVEs.Metrics.CvssMetricsV2[0].ExploitabilityScore)
		}
		// Checking if our device mark is not empty
		if cvejson.Vulnerabilities[i].CVEs.Configurations[0].Nodes[0].CpeMatch[0].Criteria == "" {
			device_mark = "Nothing here in DB"
		} else {
			device_mark = cvejson.Vulnerabilities[i].CVEs.Configurations[0].Nodes[0].CpeMatch[0].Criteria
		}
		// Parsing strings from DB to grab Model and Firmwares that are vulnarable
		// for the CVEs, CPEs, CWEs.
		device_mark, vuln_version = getModelVersion(device_mark, description_mark)
		if cvejson.Vulnerabilities[i].CVEs.Configurations[0].Nodes[0].CpeMatch[0].VersionEndIncluding != "" {
			vuln_version = cvejson.Vulnerabilities[i].CVEs.Configurations[0].Nodes[0].CpeMatch[0].VersionEndIncluding
		}
		result = append(result,
			device,
			device_mark,
			vuln_version,
			cvejson.Vulnerabilities[i].CVEs.ID,
			exploit_score,
			description_mark,
			reference_mark)
	}
	return result
}

func checkRegexp(regexpression, inputstring string) [][]byte {
	// Checking input string on the regular expression
	var m LogMessage
	re, err := regexp.Compile(regexpression)
	if err != nil {
		m.MessageType = "regular"
		m.Message = "Regexp is invalid can not regexp.Compile it."
		m.getLogger()
	}
	return re.FindAll([]byte(inputstring), -1)
}

func getModelVersion(inputs ...string) (string, string) {
	// Parsing the version from CPE-vector string in a case of VersionEndIncluding is Empty
	var model, version string
	regexps := []string{"([0-9]+\\.){1,3}[0-9]+"}
	for _, input := range inputs {
		devices := strings.Split(input, ":")
		if devices == nil || devices[0] == "" {
			log.Println("Check devices input")
		}
		if len(devices) == 1 || len(devices) == 2 || len(devices) == 3 || len(devices) == 4 {
			for _, exp := range regexps {
				for _, regex := range checkRegexp(exp, input) {
					version += string(regex) + " "
				}
			}
		} else {
			if len(devices) == 5 {
				model = devices[4] + " "
			} else {
				if devices[5] == "*" {
					continue
				}
				if checkRegexp(regexps[0], devices[5]) != nil {
					continue
				}
				model += devices[5] + " "
			}
		}
	}

	return model, version
}

func readServices(port, protocol string) string {
	// Processing Services with nmap Services file
	var m LogMessage
	service := "No Service"
	expression := "([a-z|-]){1,32}[\\t|.]" + port + "/" + protocol
	readfile, err := os.ReadFile("./assets/nmap-services.txt")
	if err != nil {
		m.MessageType = "regular"
		m.Message = "There is no file ./assets/nmap-services.txt"
		m.getLogger()
	}
	services := string(readfile)
	for _, regex := range checkRegexp(expression, services) {
		service = strings.Split(string(regex), "\t")[0]
	}
	return service
}

func getBannerVersion(banner, device string) string {
	// Banner version RegExp as it used in NVDs
	v := ""
	regexps := "([0-9]+\\.){1,3}[0-9]+"
	i := strings.Index(banner, device)
	banner = banner[i : i+len([]rune(device))+20]
	res := checkRegexp(regexps, banner)
	for _, r := range res {
		v = string(r)
	}
	return v
}

func processBanner(banner, device string) string {
	// Finding if there is any banner version is available
	version := "0.0"
	banner = strings.ToLower(banner)
	device = strings.ToLower(device)
	if strings.Contains(banner, device) {
		version = getBannerVersion(banner, device)
	}
	return version
}

func transformVersions(version string) string {
	// Transforming versions so they could be compared
	resver := ""
	version = strings.Trim(version, " ")
	// Deleting all the points to compare numbers
	stripped := strings.Split(version, ".")
	for _, strip := range stripped {
		resver += strip
	}
	// Trimming the '0' if its starts the number. As strings.LTrim isn't working properly
	if resver != "" {
		resrune := []rune(resver)
		if resrune[0] == '0' {
			resver = string(resrune[1:])
		}
	}
	return resver
}

func processBanners(scannedreports []ScanReport, network, cveport, verbose bool) {
	var keyword string
	var m LogMessage
	for r, _ := range scannedreports {
		for k, _ := range scannedreports[r].Vuln {
			if scannedreports[r].Vuln[k].VPort.Banner == "No banner" {
				if !cveport {
					break
				}
				if scannedreports[r].Vuln[k].VPort.Service != "No Service" {
					// Making keyword as service (port function) to find
					keyword = scannedreports[r].Vuln[k].VPort.Service
				} else {
					m.Message = "There is no vulnerability for this port as there is no a banner and a service :("
					m.MessageType = "regular"
					m.getLogger()
				}
			} else {
				// Making device as a service
				devices := readDevices()
				for _, device := range devices.devices["devices"] {
					version := processBanner(scannedreports[r].Vuln[k].VPort.Banner, device)
					version = transformVersions(version)
					if version != "0" {
						keyword, scannedreports[r].Vuln[k].VFirm.Device = device, device
						scannedreports[r].Vuln[k].VFirm.Firmware = version
						break
					}
				}
			}
			if network {
				// Reading and forming a request by service
				// Here I am assuming that ports and services there will be
				// Much and much more than we have 'devices' in our 'assets/keywords.json' file
				json := findKeyword(keyword)
				write := writeToFile(keyword, json)
				if write != nil {
					m.Message = "Can not write to JSON file"
					m.MessageType = "fatal"
					m.getLogger()
				}
			}
			// Reading and parsing the JSON for Service Vulnerability
			cvejson := readJSON(keyword)
			// Pre-processing json data to receive firmware to compare
			preprocess := preProcessNVD(cvejson, keyword)
			// Writing the Data
			for i := 0; i < len(preprocess); i += 7 {
				//Transforming to Float as there potential could be cases even with transformation
				// where the value would be float64
				currentfirm, _ := strconv.ParseFloat(scannedreports[r].Vuln[k].VFirm.Firmware, 64)
				vulnfirm, ferr := strconv.ParseFloat(transformVersions(preprocess[i+2]), 64)
				if ferr != nil {
					m.Message = "Some of firmwares are impossible to convert to float32 and compare"
					m.MessageType = "regular"
					if verbose {
						m.getLogger()
					}
					continue
				}
				// Checking if we need to log the vulnerability
				if currentfirm > vulnfirm {
					continue
				}
				// Logging the CVEs (now its default logging system)
				// TODO make logging to the .CSV
				scannedreports[r].Vuln[k].CVEID = preprocess[i+3]
				scannedreports[r].Vuln[k].Link = append(scannedreports[r].Vuln[k].Link, preprocess[i+6])
				scannedreports[r].logScanned()
			}
		}
	}
}
