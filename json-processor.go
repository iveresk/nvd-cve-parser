package main

import (
	"encoding/json"
	"fmt"
	"log"
	"os"
	"regexp"
	"strings"
)

type Devices struct {
	devices map[string][]string
}

type NVDRequest struct {
	ResultsPerPage  int             `json:"resultsPerPage"`
	StartIndex      int             `json:"startIndex"`
	TotalResults    int             `json:"totalResults"`
	Format          string          `json:"format"`
	Version         string          `json:"version"`
	Timestamp       string          `json:"timestamp"`
	Vulnerabilities []Vulnerability `json:"vulnerabilities"`
}

type Vulnerability struct {
	CVEs CVE `json:"cve"`
}

type CVE struct {
	ID               string          `json:"id"`
	SourceIdentifier string          `json:"sourceIdentifier"`
	Published        string          `json:"published"`
	LastModified     string          `json:"lastModified"`
	VulnStatus       string          `json:"vulnStatus"`
	Descriptions     []Description   `json:"descriptions"`
	Metrics          Metric          `json:"metrics"`
	Weaknesses       []Weakness      `json:"weaknesses"`
	Configurations   []Configuration `json:"configurations"`
	References       []Reference     `json:"references"`
}

type Metric struct {
	CvssMetricsV2 []CVSSMetricsV2 `json:"cvssMetricV2"`
}

type CVSSMetricsV2 struct {
	Source                  string   `json:"source"`
	Type                    string   `json:"type"`
	cvssData                CVSSData `json:"cvssData"`
	ExploitabilityScore     float64  `json:"exploitabilityScore"`
	ImpactScore             float64  `json:"impactScore"`
	AcInsufInfo             bool     `json:"acInsufInfo"`
	ObtainAllPrivilege      bool     `json:"obtainAllPrivilege"`
	ObtainUserPrivilege     bool     `json:"obtainUserPrivilege"`
	ObtainOtherPrivilege    bool     `json:"obtainOtherPrivilege"`
	UserInteractionRequired bool     `json:"userInteractionRequired"`
}

type CVSSData struct {
	Version               string  `json:"version"`
	VectorString          string  `json:"vectorString"`
	AccessVector          string  `json:"accessVector"`
	AccessComplexity      string  `json:"accessComplexity"`
	Authentication        string  `json:"authentication"`
	ConfidentialityImpact string  `json:"confidentialityImpact"`
	IntegrityImpact       string  `json:"integrityImpact"`
	AvailabilityImpact    string  `json:"availabilityImpact"`
	BaseScore             float64 `json:"baseScore"`
	BaseSeverity          string  `json:"baseSeverity"`
}

type Weakness struct {
	Source      string        `json:"source"`
	Type        string        `json:"type"`
	Description []Description `json:"description"`
}

type Configuration struct {
	Nodes []Node `json:"nodes"`
}

type Reference struct {
	URL    string   `json:"url"`
	Source string   `json:"source"`
	Tags   []string `json:"tags,omitempty"`
}

type Description struct {
	Lang  string `json:"lang"`
	Value string `json:"value"`
}

type Node struct {
	Operator string     `json:"operator"`
	Negate   bool       `json:"negate"`
	CpeMatch []CPEMatch `json:"cpeMatch"`
}

type CPEMatch struct {
	Vulnerable      bool   `json:"vulnerable"`
	Criteria        string `json:"criteria"`
	MatchCriteriaID string `json:"matchCriteriaId"`
}

func readDevices() Devices {
	var m LogMessage
	filepath := "./assets/keywords.json"
	// reading the device-keywords.json file
	dcontent, err := os.ReadFile(filepath)
	if err != nil {
		m.MessageType = "regular"
		m.Message = "There is no file " + filepath
		m.getLogger()
	}
	var devices Devices
	err = json.Unmarshal(dcontent, &devices.devices)
	if err != nil || &devices.devices == nil {
		m.MessageType = "regular"
		m.Message = "Check if the file " + filepath + " is in json format"
		m.getLogger()
	}
	return devices
}

func readJSON(device string) NVDRequest {
	var m LogMessage
	filepath := "./assets/" + device + ".json"
	dcontent, err := os.ReadFile(filepath)
	if err != nil {
		m.Message = "There is no file " + filepath +
			"\n Try -n 'network' key to process the CVEs for the keyword"
		m.MessageType = "regular"
		m.getLogger()
	}
	var nvdRequest NVDRequest
	err = json.Unmarshal(dcontent, &nvdRequest)
	if err != nil && nvdRequest.Vulnerabilities == nil {
		m.MessageType = "regular"
		m.Message = "Check if the file " + filepath + " is in json format"
		m.getLogger()
	}
	if err != nil {
		log.Println("Not all the file " + filepath + " was processed")
		log.Println(err)
	}
	return nvdRequest
}

func writeToFile(filename string, byte []byte) error {
	return os.WriteFile("./assets/"+filename+".json", byte, 0666)
}

func preProcessNVD(cvejson NVDRequest, device string) []string {
	// Defining variables to have a complex check
	var result []string
	var device_mark string
	var vuln_version string
	var reference_mark string
	var description_mark string
	var exploit_score string

	// TODO Make pagination for the processing
	for i := cvejson.ResultsPerPage - 1; i >= 0; i-- {
		// Checking the Data on structure and on integrity
		if len(cvejson.Vulnerabilities) == 0 {
			continue
		}
		if cvejson.Vulnerabilities == nil ||
			cvejson.Vulnerabilities[i].CVEs.Metrics.CvssMetricsV2 == nil ||
			cvejson.Vulnerabilities[i].CVEs.Descriptions == nil ||
			cvejson.Vulnerabilities[i].CVEs.References == nil ||
			cvejson.Vulnerabilities[i].CVEs.Configurations == nil ||
			cvejson.Vulnerabilities[i].CVEs.Configurations[0].Nodes == nil ||
			cvejson.Vulnerabilities[i].CVEs.Configurations[0].Nodes[0].CpeMatch == nil {
			continue
		}
		// Checking on integrity of the data in DB
		if len(cvejson.Vulnerabilities[i].CVEs.References) == 0 {
			reference_mark = "Nothing here in DB"
		} else {
			reference_mark = cvejson.Vulnerabilities[i].CVEs.References[0].URL
		}
		if len(cvejson.Vulnerabilities[i].CVEs.Descriptions) == 0 {
			description_mark = "Nothing here in DB"
		} else {
			description_mark = cvejson.Vulnerabilities[i].CVEs.Descriptions[0].Value
		}

		if len(cvejson.Vulnerabilities[i].CVEs.Metrics.CvssMetricsV2) == 0 {
			exploit_score = "Nothing here in DB"
		} else {
			if cvejson.Vulnerabilities[i].CVEs.Metrics.CvssMetricsV2[0].ExploitabilityScore < 7.0 {
				continue
			}
			exploit_score = fmt.Sprintf("%f", cvejson.Vulnerabilities[i].CVEs.Metrics.CvssMetricsV2[0].ExploitabilityScore)
		}
		// Checking if our device mark is not empty
		if cvejson.Vulnerabilities[i].CVEs.Configurations[0].Nodes[0].CpeMatch[0].Criteria == "" {
			device_mark = "Nothing here in DB"
		} else {
			device_mark = cvejson.Vulnerabilities[i].CVEs.Configurations[0].Nodes[0].CpeMatch[0].Criteria
		}
		// Parsing strings from DB to grab Model and Firmwares that are vulnarable
		// for the CVEs, CPEs, CWEs.
		device_mark, vuln_version = getModelVersion(device_mark, description_mark)
		result = append(result,
			device,
			device_mark,
			vuln_version,
			cvejson.Vulnerabilities[i].CVEs.ID,
			exploit_score,
			description_mark,
			reference_mark)
	}
	return result
}

func checkRegexp(regexpression, inputstring string) [][]byte {
	var m LogMessage
	re, err := regexp.Compile(regexpression)
	if err != nil {
		m.MessageType = "regular"
		m.Message = "Regexp is invalid can not regexp.Compile it."
		m.getLogger()
	}
	return re.FindAll([]byte(inputstring), -1)
}

func getModelVersion(inputs ...string) (string, string) {
	var model, version string
	regexps := []string{"([0-9]\\.){1,3}[0-9]+"}
	for _, input := range inputs {
		devices := strings.Split(input, ":")
		if devices == nil || devices[0] == "" {
			log.Println("Check devices input")
		}
		if len(devices) == 1 || len(devices) == 2 || len(devices) == 3 || len(devices) == 4 {
			for _, exp := range regexps {
				for _, regex := range checkRegexp(exp, input) {
					version += string(regex) + " "
				}
			}
		} else {
			if len(devices) == 5 {
				model = devices[4] + " "
			} else {
				if devices[5] == "*" {
					continue
				}
				if checkRegexp(regexps[0], devices[5]) != nil {
					continue
				}
				model += devices[5] + " "
			}
		}
	}

	return model, version
}

func readServices(port, protocol string) string {
	var m LogMessage
	service := "No Service"
	expression := "([a-z|-]){1,32}[\\t|.]" + port + "/" + protocol
	readfile, err := os.ReadFile("./assets/nmap-services.txt")
	if err != nil {
		m.MessageType = "regular"
		m.Message = "There is no file ./assets/nmap-services.txt"
		m.getLogger()
	}
	services := string(readfile)
	for _, regex := range checkRegexp(expression, services) {
		service = strings.Split(string(regex), "\t")[0]
	}
	return service
}
